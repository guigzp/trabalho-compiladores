; ModuleID = 'nbody.rbc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%struct.planet = type { double, double, double, double, double, double, double }

@bodies = global [5 x %struct.planet] [%struct.planet { double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0x4043BD3CC9BE45DE }, %struct.planet { double 0x40135DA0343CD92C, double 0xBFF290ABC01FDB7C, double 0xBFBA86F96C25EBF0, double 0x3FE367069B93CCBC, double 0x40067EF2F57D949B, double 0xBF99D2D79A5A0715, double 0x3FA34C95D9AB33D8 }, %struct.planet { double 0x4020AFCDC332CA67, double 0x40107FCB31DE01B0, double 0xBFD9D353E1EB467C, double 0xBFF02C21B8879442, double 0x3FFD35E9BF1F8F13, double 0x3F813C485F1123B4, double 0x3F871D490D07C637 }, %struct.planet { double 0x4029C9EACEA7D9CF, double 0xC02E38E8D626667E, double 0xBFCC9557BE257DA0, double 0x3FF1531CA9911BEF, double 0x3FEBCC7F3E54BBC5, double 0xBF862F6BFAF23E7C, double 0x3F5C3DD29CF41EB3 }, %struct.planet { double 0x402EC267A905572A, double 0xC039EB5833C8A220, double 0x3FC6F1F393ABE540, double 0x3FEF54B61659BC4A, double 0x3FE307C631C4FBA3, double 0xBFA1CB88587665F6, double 0x3F60A8F3531799AC }], align 16
@.str = private unnamed_addr constant [6 x i8] c"%.9f\0A\00", align 1

; Function Attrs: noinline nounwind uwtable
define void @advance(i32, %struct.planet*, double) local_unnamed_addr #0 {
  %4 = icmp sgt i32 %0, 0
  br i1 %4, label %.lr.ph10, label %._crit_edge

.lr.ph10:                                         ; preds = %3
  %5 = sext i32 %0 to i64
  %wide.trip.count16 = zext i32 %0 to i64
  %.pre = zext i32 %0 to i64
  %wide.trip.count16.le = zext i32 %0 to i64
  br label %6

; <label>:6:                                      ; preds = %._crit_edge7, %.lr.ph10
  %indvars.iv18 = phi i64 [ 0, %.lr.ph10 ], [ %indvars.iv.next19, %._crit_edge7 ]
  %indvars.iv12 = phi i64 [ 1, %.lr.ph10 ], [ %indvars.iv.next13, %._crit_edge7 ]
  %indvars.iv.next19 = add nuw nsw i64 %indvars.iv18, 1
  %7 = icmp slt i64 %indvars.iv.next19, %5
  br i1 %7, label %.lr.ph6, label %._crit_edge7

.lr.ph6:                                          ; preds = %6
  %8 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv18, i32 0
  %9 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv18, i32 2
  %10 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv18, i32 3
  %11 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv18, i32 5
  %12 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv18, i32 6
  %13 = bitcast double* %8 to <2 x double>*
  %14 = bitcast double* %10 to <2 x double>*
  %15 = bitcast double* %10 to <2 x double>*
  br label %16

; <label>:16:                                     ; preds = %16, %.lr.ph6
  %indvars.iv14 = phi i64 [ %indvars.iv12, %.lr.ph6 ], [ %indvars.iv.next15, %16 ]
  %17 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 0
  %18 = load <2 x double>, <2 x double>* %13, align 8
  %19 = bitcast double* %17 to <2 x double>*
  %20 = load <2 x double>, <2 x double>* %19, align 8
  %21 = fsub <2 x double> %18, %20
  %22 = load double, double* %9, align 8
  %23 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 2
  %24 = load double, double* %23, align 8
  %25 = fsub double %22, %24
  %26 = extractelement <2 x double> %21, i32 0
  %27 = fmul double %26, %26
  %28 = extractelement <2 x double> %21, i32 1
  %29 = fmul double %28, %28
  %30 = fadd double %27, %29
  %31 = fmul double %25, %25
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #3
  %34 = fmul double %33, %33
  %35 = fmul double %33, %34
  %36 = fdiv double %2, %35
  %37 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 6
  %38 = load double, double* %37, align 8
  %39 = insertelement <2 x double> undef, double %38, i32 0
  %40 = shufflevector <2 x double> %39, <2 x double> undef, <2 x i32> zeroinitializer
  %41 = fmul <2 x double> %21, %40
  %42 = insertelement <2 x double> undef, double %36, i32 0
  %43 = shufflevector <2 x double> %42, <2 x double> undef, <2 x i32> zeroinitializer
  %44 = fmul <2 x double> %41, %43
  %45 = load <2 x double>, <2 x double>* %14, align 8
  %46 = fsub <2 x double> %45, %44
  store <2 x double> %46, <2 x double>* %15, align 8
  %47 = fmul double %25, %38
  %48 = fmul double %36, %47
  %49 = load double, double* %11, align 8
  %50 = fsub double %49, %48
  store double %50, double* %11, align 8
  %51 = load double, double* %12, align 8
  %52 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 3
  %53 = insertelement <2 x double> undef, double %51, i32 0
  %54 = shufflevector <2 x double> %53, <2 x double> undef, <2 x i32> zeroinitializer
  %55 = fmul <2 x double> %21, %54
  %56 = fmul <2 x double> %43, %55
  %57 = bitcast double* %52 to <2 x double>*
  %58 = load <2 x double>, <2 x double>* %57, align 8
  %59 = fadd <2 x double> %58, %56
  %60 = bitcast double* %52 to <2 x double>*
  store <2 x double> %59, <2 x double>* %60, align 8
  %61 = fmul double %25, %51
  %62 = fmul double %36, %61
  %63 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 5
  %64 = load double, double* %63, align 8
  %65 = fadd double %64, %62
  store double %65, double* %63, align 8
  %indvars.iv.next15 = add nuw nsw i64 %indvars.iv14, 1
  %exitcond17 = icmp eq i64 %indvars.iv.next15, %wide.trip.count16
  br i1 %exitcond17, label %._crit_edge7, label %16

._crit_edge7:                                     ; preds = %16, %6
  %wide.trip.count20.pre-phi = phi i64 [ %.pre, %6 ], [ %wide.trip.count16.le, %16 ]
  %indvars.iv.next13 = add nuw nsw i64 %indvars.iv12, 1
  %exitcond21 = icmp eq i64 %indvars.iv.next19, %wide.trip.count20.pre-phi
  br i1 %exitcond21, label %._crit_edge11, label %6

._crit_edge11:                                    ; preds = %._crit_edge7
  br i1 %4, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %._crit_edge11
  %66 = insertelement <2 x double> undef, double %2, i32 0
  %67 = shufflevector <2 x double> %66, <2 x double> undef, <2 x i32> zeroinitializer
  %wide.trip.count = zext i32 %0 to i64
  br label %68

; <label>:68:                                     ; preds = %68, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %68 ]
  %69 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 3
  %70 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 0
  %71 = bitcast double* %69 to <2 x double>*
  %72 = load <2 x double>, <2 x double>* %71, align 8
  %73 = fmul <2 x double> %67, %72
  %74 = bitcast double* %70 to <2 x double>*
  %75 = load <2 x double>, <2 x double>* %74, align 8
  %76 = fadd <2 x double> %75, %73
  %77 = bitcast double* %70 to <2 x double>*
  store <2 x double> %76, <2 x double>* %77, align 8
  %78 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 5
  %79 = load double, double* %78, align 8
  %80 = fmul double %79, %2
  %81 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 2
  %82 = load double, double* %81, align 8
  %83 = fadd double %82, %80
  store double %83, double* %81, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %._crit_edge, label %68

._crit_edge:                                      ; preds = %68, %3, %._crit_edge11
  ret void
}

; Function Attrs: nounwind
declare double @sqrt(double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define double @energy(i32, %struct.planet* nocapture readonly) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %0, 0
  br i1 %3, label %.lr.ph9, label %._crit_edge10

.lr.ph9:                                          ; preds = %2
  %4 = sext i32 %0 to i64
  %wide.trip.count = zext i32 %0 to i64
  %.pre = zext i32 %0 to i64
  %wide.trip.count.le = zext i32 %0 to i64
  br label %5

; <label>:5:                                      ; preds = %._crit_edge, %.lr.ph9
  %indvars.iv14 = phi i64 [ 0, %.lr.ph9 ], [ %indvars.iv.next15, %._crit_edge ]
  %indvars.iv = phi i64 [ 1, %.lr.ph9 ], [ %indvars.iv.next, %._crit_edge ]
  %.026 = phi double [ 0.000000e+00, %.lr.ph9 ], [ %.1.lcssa, %._crit_edge ]
  %6 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 6
  %7 = load double, double* %6, align 8
  %8 = fmul double %7, 5.000000e-01
  %9 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 3
  %10 = load double, double* %9, align 8
  %11 = fmul double %10, %10
  %12 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 4
  %13 = load double, double* %12, align 8
  %14 = fmul double %13, %13
  %15 = fadd double %11, %14
  %16 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 5
  %17 = load double, double* %16, align 8
  %18 = fmul double %17, %17
  %19 = fadd double %15, %18
  %20 = fmul double %8, %19
  %21 = fadd double %.026, %20
  %indvars.iv.next15 = add nuw nsw i64 %indvars.iv14, 1
  %22 = icmp slt i64 %indvars.iv.next15, %4
  br i1 %22, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %5
  %23 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 0
  %24 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 1
  %25 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv14, i32 2
  br label %26

; <label>:26:                                     ; preds = %26, %.lr.ph
  %indvars.iv12 = phi i64 [ %indvars.iv, %.lr.ph ], [ %indvars.iv.next13, %26 ]
  %.14 = phi double [ %21, %.lr.ph ], [ %54, %26 ]
  %27 = load double, double* %23, align 8
  %28 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv12, i32 0
  %29 = load double, double* %28, align 8
  %30 = load double, double* %24, align 8
  %31 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv12, i32 1
  %32 = load double, double* %31, align 8
  %33 = fsub double %30, %32
  %34 = load double, double* %25, align 8
  %35 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv12, i32 2
  %36 = load double, double* %35, align 8
  %37 = insertelement <2 x double> undef, double %27, i32 0
  %38 = insertelement <2 x double> %37, double %34, i32 1
  %39 = insertelement <2 x double> undef, double %29, i32 0
  %40 = insertelement <2 x double> %39, double %36, i32 1
  %41 = fsub <2 x double> %38, %40
  %42 = fmul double %33, %33
  %43 = fmul <2 x double> %41, %41
  %44 = extractelement <2 x double> %43, i32 0
  %45 = fadd double %44, %42
  %46 = extractelement <2 x double> %43, i32 1
  %47 = fadd double %45, %46
  %48 = tail call double @sqrt(double %47) #3
  %49 = load double, double* %6, align 8
  %50 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv12, i32 6
  %51 = load double, double* %50, align 8
  %52 = fmul double %49, %51
  %53 = fdiv double %52, %48
  %54 = fsub double %.14, %53
  %indvars.iv.next13 = add nuw nsw i64 %indvars.iv12, 1
  %exitcond = icmp eq i64 %indvars.iv.next13, %wide.trip.count
  br i1 %exitcond, label %._crit_edge, label %26

._crit_edge:                                      ; preds = %26, %5
  %wide.trip.count16.pre-phi = phi i64 [ %.pre, %5 ], [ %wide.trip.count.le, %26 ]
  %.1.lcssa = phi double [ %21, %5 ], [ %54, %26 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond17 = icmp eq i64 %indvars.iv.next15, %wide.trip.count16.pre-phi
  br i1 %exitcond17, label %._crit_edge10, label %5

._crit_edge10:                                    ; preds = %._crit_edge, %2
  %.02.lcssa = phi double [ 0.000000e+00, %2 ], [ %.1.lcssa, %._crit_edge ]
  ret double %.02.lcssa
}

; Function Attrs: noinline norecurse nounwind uwtable
define void @offset_momentum(i32, %struct.planet* nocapture) local_unnamed_addr #2 {
  %3 = icmp sgt i32 %0, 0
  br i1 %3, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2
  %4 = zext i32 %0 to i64
  %xtraiter = and i64 %4, 1
  %5 = icmp eq i32 %0, 1
  br i1 %5, label %._crit_edge.loopexit.unr-lcssa, label %.lr.ph.new

.lr.ph.new:                                       ; preds = %.lr.ph
  %unroll_iter = sub nsw i64 %4, %xtraiter
  br label %6

; <label>:6:                                      ; preds = %6, %.lr.ph.new
  %indvars.iv = phi i64 [ 0, %.lr.ph.new ], [ %indvars.iv.next.1, %6 ]
  %.016 = phi double [ 0.000000e+00, %.lr.ph.new ], [ %26, %6 ]
  %7 = phi <2 x double> [ zeroinitializer, %.lr.ph.new ], [ %33, %6 ]
  %niter = phi i64 [ %unroll_iter, %.lr.ph.new ], [ %niter.nsub.1, %6 ]
  %8 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 5
  %9 = load double, double* %8, align 8
  %10 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 6
  %11 = load double, double* %10, align 8
  %12 = fmul double %9, %11
  %13 = fadd double %.016, %12
  %14 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv, i32 3
  %15 = bitcast double* %14 to <2 x double>*
  %16 = load <2 x double>, <2 x double>* %15, align 8
  %17 = insertelement <2 x double> undef, double %11, i32 0
  %18 = shufflevector <2 x double> %17, <2 x double> undef, <2 x i32> zeroinitializer
  %19 = fmul <2 x double> %16, %18
  %20 = fadd <2 x double> %7, %19
  %indvars.iv.next = or i64 %indvars.iv, 1
  %21 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.next, i32 5
  %22 = load double, double* %21, align 8
  %23 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.next, i32 6
  %24 = load double, double* %23, align 8
  %25 = fmul double %22, %24
  %26 = fadd double %13, %25
  %27 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.next, i32 3
  %28 = bitcast double* %27 to <2 x double>*
  %29 = load <2 x double>, <2 x double>* %28, align 8
  %30 = insertelement <2 x double> undef, double %24, i32 0
  %31 = shufflevector <2 x double> %30, <2 x double> undef, <2 x i32> zeroinitializer
  %32 = fmul <2 x double> %29, %31
  %33 = fadd <2 x double> %20, %32
  %indvars.iv.next.1 = add nuw nsw i64 %indvars.iv, 2
  %niter.nsub.1 = add i64 %niter, -2
  %niter.ncmp.1 = icmp eq i64 %niter.nsub.1, 0
  br i1 %niter.ncmp.1, label %._crit_edge.loopexit.unr-lcssa, label %6

._crit_edge.loopexit.unr-lcssa:                   ; preds = %6, %.lr.ph
  %.lcssa16.ph = phi double [ undef, %.lr.ph ], [ %26, %6 ]
  %.lcssa.ph = phi <2 x double> [ undef, %.lr.ph ], [ %33, %6 ]
  %indvars.iv.unr = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next.1, %6 ]
  %.016.unr = phi double [ 0.000000e+00, %.lr.ph ], [ %26, %6 ]
  %.unr = phi <2 x double> [ zeroinitializer, %.lr.ph ], [ %33, %6 ]
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %._crit_edge, label %.epil.preheader

.epil.preheader:                                  ; preds = %._crit_edge.loopexit.unr-lcssa
  %34 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.unr, i32 6
  %35 = load double, double* %34, align 8
  %36 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.unr, i32 3
  %37 = bitcast double* %36 to <2 x double>*
  %38 = load <2 x double>, <2 x double>* %37, align 8
  %39 = insertelement <2 x double> undef, double %35, i32 0
  %40 = shufflevector <2 x double> %39, <2 x double> undef, <2 x i32> zeroinitializer
  %41 = fmul <2 x double> %38, %40
  %42 = fadd <2 x double> %.unr, %41
  %43 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 %indvars.iv.unr, i32 5
  %44 = load double, double* %43, align 8
  %45 = fmul double %44, %35
  %46 = fadd double %.016.unr, %45
  br label %._crit_edge

._crit_edge:                                      ; preds = %.epil.preheader, %._crit_edge.loopexit.unr-lcssa, %2
  %.01.lcssa = phi double [ 0.000000e+00, %2 ], [ %.lcssa16.ph, %._crit_edge.loopexit.unr-lcssa ], [ %46, %.epil.preheader ]
  %47 = phi <2 x double> [ zeroinitializer, %2 ], [ %.lcssa.ph, %._crit_edge.loopexit.unr-lcssa ], [ %42, %.epil.preheader ]
  %48 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 0, i32 3
  %49 = fsub <2 x double> <double -0.000000e+00, double -0.000000e+00>, %47
  %50 = fdiv <2 x double> %49, <double 0x4043BD3CC9BE45DE, double 0x4043BD3CC9BE45DE>
  %51 = bitcast double* %48 to <2 x double>*
  store <2 x double> %50, <2 x double>* %51, align 8
  %52 = fsub double -0.000000e+00, %.01.lcssa
  %53 = fdiv double %52, 0x4043BD3CC9BE45DE
  %54 = getelementptr inbounds %struct.planet, %struct.planet* %1, i64 0, i32 5
  store double %53, double* %54, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define i32 @main(i32, i8** nocapture readnone) local_unnamed_addr #0 {
  tail call void @offset_momentum(i32 5, %struct.planet* getelementptr inbounds ([5 x %struct.planet], [5 x %struct.planet]* @bodies, i64 0, i64 0))
  %3 = tail call double @energy(i32 5, %struct.planet* getelementptr inbounds ([5 x %struct.planet], [5 x %struct.planet]* @bodies, i64 0, i64 0))
  %4 = tail call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0), double %3)
  br label %5

; <label>:5:                                      ; preds = %5, %2
  %.01 = phi i32 [ 1, %2 ], [ %6, %5 ]
  tail call void @advance(i32 5, %struct.planet* getelementptr inbounds ([5 x %struct.planet], [5 x %struct.planet]* @bodies, i64 0, i64 0), double 1.000000e-02)
  %6 = add nuw nsw i32 %.01, 1
  %exitcond = icmp eq i32 %6, 5000001
  br i1 %exitcond, label %7, label %5

; <label>:7:                                      ; preds = %5
  %8 = tail call double @energy(i32 5, %struct.planet* getelementptr inbounds ([5 x %struct.planet], [5 x %struct.planet]* @bodies, i64 0, i64 0))
  %9 = tail call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0), double %8)
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @printf(i8* nocapture readonly, ...) local_unnamed_addr #1

attributes #0 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noinline norecurse nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
